# I/O 多路复用为哪般？
> 这是 Netty 系列文章的第三篇，为 Netty 采用的多路复用 I/O 模型做铺垫。主要讲操作系统网络 I/O 机制，以及三种 I/O 模型。主要关注的三个问题：

- 什么是 I/O 模型？
- 为什么 I/O 影响网络编程框架效率？
- 什么是 I/O 多路复用？ I/O 多路复用的优缺点？

## I/O 基础

### I/O 基础知识
什么是 I/O?
> I/O 是 input/output ，即输入／输出，常见的有网络 I/O 和磁盘 I/O ，这里的输入输出是从内存的视角出发，将磁盘、网卡的数据写入内存视为输入，反之视为输出。

什么是 I/O 模型？
> I/O 模型可以理解为计算机进行输入输入的方式。

I/O 模型有什么作用？
> I/O 模型在很大程度决定了计算机 I/O 的效率。

### I/O 请求的两个阶段
I/O 请求分为两个阶段，调用阶段和执行阶段:

![](https://files.mdnice.com/user/22260/aea44e31-04ae-4bb4-ae79-e9bff381114e.jpg)

- I/O 调用阶段：应用进程向内核发起系统调用；
- I/O 执行阶段：内核等待 I/O 请求处理完成返回。该阶段分为两个过程：首先等待数据就绪，并写入内核缓冲区；随后将内核缓冲区数据拷贝至用户态缓冲区。

### Unix 五种 I/O 模型

Unix 操作系统中有五种 I/O 模型：
- 同步阻塞 I/O
- 同步非阻塞 I/O
- I/O 多路复用
- 信号驱动 I/O
- 异步 I/O



### 网络 I/O
**网络 I/O 指的是网卡与内存之间的输入输出。** 当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。


## 三种 I/O 模型

### BIO(Blocking I/O) 同步阻塞

BIO 是同步阻塞 I/O ，同步是发起调用接收到数据才返回，阻塞是线程等待，而不会切换去执行其他任务。

BIO 的设计好比：

> 小区门口有一个信箱，张三去取信。他的信没到的时候就一直等，直到他收到要接收的信才回去。中间过程一直阻塞在那里，浪费了他很多时间。

![BIO示意图](https://files.mdnice.com/user/22260/3bba3f51-5d82-442f-9e12-6dc8d5f4d971.jpg)

采用 BIO 模型的应用程序，向发起操作系统发起内核调用后，一直阻塞等待内核返回数据。所以 BIO 在实现异步操作时，只能使用多线程模型，一个请求对应一个线程。但是，线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。


![](https://files.mdnice.com/user/22260/b4bbc40d-7f23-4bb7-b2c0-e667829a50b7.png)


BIO 效率不高，适合连接数目少且固定的场景，是 JDK 1.4 以前唯一的选择，但程序易于理解和编码。

### 同步非阻塞 I/O(Non-blocking I/O)
既然 BIO 的缺陷是因为线程阻塞等待，导致效率不高。那么就会自然地想到不阻塞的方案 —— 同步非阻塞 I/O 。

同步非阻塞 I/O 好比：
> 还是那个信箱，还是张三。他去小区门口发现他的信还没送到，就回家干别的事情。隔上一段时间再来看看有没有他的信，直到在信箱发现他的信并取走。他少了等待的时间，但却要反复去信箱看他的信到了没有。

![同步非阻塞IO](https://files.mdnice.com/user/22260/8bd8f722-4487-4efd-8430-69dba09ac07c.jpg)

同步非阻塞 I/O 相比于同步阻塞 I/O 效率更高了，因为没有阻塞。但是频繁的上下文切换也会带来很大开销。

### I/O 多路复用

针对同步非阻塞 I/O 存在的问题，又有了一种新的解决方案：I/O 多路复用。

I/O 多路复用好比：

> 找了一个人，一直守在信箱那里。张三的信来了就通知张三来取，李四的信就通知李四，这样需要取信的人就避免了频繁去查看信箱。

I/O 多路复用相比于同步非阻塞 I/O ，使用了操作系统 select、poll/epoll 等机制，使用一个线程监听注册在 selector 多个 socket 连接。避免了线程频繁切换的上下文开销。

![](https://files.mdnice.com/user/22260/59891898-b8dd-4858-a24a-802e7e75257f.jpg)

I/O 多路复用中，多路指多个连接通道，复用指复用一个或多个固定线程处理 socket 的 I/O 事件。select、poll、epoll 都是 I/O 多路复用的具体实现，线程一次 select 调用可以获取内核态中多个数据通道的数据状态。多路复用通过减少无效的系统调用，解决了同步非阻塞 I/O 的线程频繁切换的问题，减少了对 CPU 资源的消耗，是一种非常高效的 I/O 模型。

![](https://files.mdnice.com/user/22260/319b6939-7415-4932-b3f9-5659862c131b.png)

> select、poll、epoll 是操作系统提供的系统调用，用来监视多个 socket 连接，一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。目前主流的操作系统都支持 select 调用；poll 是对 select 的改进，epoll 是 poll 的增强版，要 linux 内核 2.6 以上才支持。

I/O 多路复用适合连接并发量大且处理耗时短的场景，比如：分布式集群节点间通信、RPC 框架、即时消息系统 IM。但对于耗时长的计算，会引起阻塞，这块在 Reactor 模型会细讲。

### 总结
- I/O 模型：

> I/O 模型是计算机处理 I/O 的方式，I/O 模型很大程度是哪个网络 I/O 的效率。

- 从 BIO 到 I/O 多路复用的演化：

> BIO：同步阻塞 I/O，简单易懂但效率不高；

> 同步非阻塞 I/O：解决了 BIO 的阻塞问题，但上下文切换频繁开销大；

> I/O 多路复用：使用一个线程监听多个 socket 状态，高效率的 I/O 模型，适合并发量大且处理耗时短的场景。

## 参考
[网络I/O原理、I/O模型及Linux监控命令](https://cloud.tencent.com/developer/article/1446813)

[为什么网络 I/O 会被阻塞？](https://zhuanlan.zhihu.com/p/420974156)

[一文搞懂select、poll和epoll区别](https://zhuanlan.zhihu.com/p/272891398)

[Java IO模型详解](https://javaguide.cn/java/io/io-model.html)
